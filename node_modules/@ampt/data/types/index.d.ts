export type getOptions = {
  meta?: boolean
  reverse?: boolean
  limit?: number
  start?: string
  label?: labels
}

export type setOptions = {
  ttl?: number | string | null
  overwrite?: boolean
  label1?: string | [string] | null
  label2?: string | [string] | null
  label3?: string | [string] | null
  label4?: string | [string] | null
  label5?: string | [string] | null
  default?: any
  created?: number
  removeNulls?: boolean
  exists?: boolean // true = don't overwrite if the item exists, false = don't write if the item doesn't exist
  meta?: boolean
}

export interface scanOptions {
  meta?: boolean
  limit?: number
  start?: string
  label?: labels
  attributes?: string[]
  segment?: number
  totalSegments?: number
  count?: boolean
}

export interface seedOptions {
  overwrite?: boolean
}

export type setBatchOptions =
  | {
      meta?: boolean // for returning updated item
      removeNulls?: boolean
    }
  | boolean

export type addOptions = {
  overwrite?: boolean
  meta?: boolean
}

export type Optional<T> = T | undefined

type WithMeta<T> = T & { meta?: any }

export type KeyValue<T> = {
  key: string
  value: WithMeta<T>
}

export type GetResponse<T> = KeyValue<T> | T | undefined

export type GetBatchResponse<T> = {
  items: KeyValue<T>[]
  lastKey?: string
  next?: () => Promise<GetResponse<T> | undefined>
}

export type ScanResponse<T> = Optional<{
  items: KeyValue<T>[]
  lastKey?: string
  next?: () => Promise<ScanResponse<T>>
}>

export type BatchSetItem<T> = {
  key: string
  value: T
  default?: Partial<T>
  ttl?: number
  label1?: string
  label2?: string
  label3?: string
  label4?: string
  label5?: string
}

export type SetResponse<T> = KeyValue<T> | T
export type SetBatchResponse<T> = { items: KeyValue<T>[]; unprocessed?: KeyValue<T>[] }

export type AddResponse<T> = KeyValue<T> | T | undefined

export type labels = 'label1' | 'label2' | 'label3' | 'label4' | 'label5'

export type indexPk = `pk${string}`
export type indexSk = `sk${string}`
export interface key {
  pk: string
  sk: string
  [key: indexPk]: string
  [key: indexSk]: string
  kv?: boolean
  default?: boolean
}

// .get types
type Whitespace = '\n' | ' '
type Trim<T> = T extends `${Whitespace}${infer U}` ? Trim<U> : T extends `${infer U}${Whitespace}` ? Trim<U> : T
type WildcardQuery = `${string}:${string | ''}*`
type ComparisonQuery = `${string}:${string | ''}${Trim<'<'> | Trim<'>'> | Trim<'<='> | Trim<'>='>}${string}`
type RangeQuery = `${string}:${string}${Trim<'|'>}${string}`
type ValidListeners = 'created' | 'updated' | 'deleted' | '*'
type ListenerPath = ValidListeners | `${ValidListeners}:${string}` | `${ValidListeners}:${WildcardQuery}`
export type Query = WildcardQuery | ComparisonQuery | RangeQuery

type DataEventHandler = (event: { previous?: any; item: any; name: ValidListeners }) => void

export declare interface Data {
  get<T>(keys: Query | string[], options?: getOptions | boolean): Promise<GetBatchResponse<T>>
  get<T>(keys: string, options?: getOptions | boolean): Promise<GetResponse<T>>
  getByLabel<T>(label: labels, keys: Query | string[], options?: getOptions | boolean): Promise<GetBatchResponse<T>>
  getByLabel<T>(label: labels, keys: string, options?: getOptions | boolean): Promise<GetResponse<T>>
  scan<T>(options: scanOptions | boolean): Promise<ScanResponse<T>>
  set<T>(keys: BatchSetItem<T>[], opts?: setBatchOptions | boolean): Promise<SetBatchResponse<T>>
  set<T>(keys: string, value: T, opts?: setOptions | boolean): Promise<SetResponse<T>>
  seed(data: any[] | string, options?: { overwrite?: boolean } | boolean): Promise<{ items: number }>
  remove(keys: string | string[]): Promise<boolean>
  add<T>(key: string, value: number, opts?: addOptions | boolean): Promise<AddResponse<T>>
  add<T>(
    key: string,
    attribute: number | string,
    value: number | addOptions | boolean,
    opts?: addOptions | boolean
  ): Promise<AddResponse<T>>
  on: (
    name: ListenerPath | ListenerPath[],
    ...handler: [{ timeout: number }, DataEventHandler] | [DataEventHandler]
  ) => void
}

export declare const data: Data
